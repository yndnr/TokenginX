# v0.1.0 MVP 测试任务清单

本文档详细列出 v0.1.0（MVP）版本的所有测试任务，确保代码质量和系统稳定性。

## 测试目标

**总工时**：38 小时
**测试人员**：1 名专职测试 + 开发协助
**覆盖率目标**：单元测试 > 80%，集成测试覆盖核心流程

**质量标准**：
- ✅ 所有单元测试通过
- ✅ 无数据竞争（`go test -race` 通过）
- ✅ 性能达标（QPS > 100K, P99 < 1ms）
- ✅ 集成测试覆盖主要场景
- ✅ 压力测试验证稳定性

## 1. 单元测试（16 小时）

### 1.1 存储引擎测试（6h）

**Issue**: `[Test] 存储引擎单元测试`
**优先级**: P0
**预估**: 6h
**负责**: 测试工程师

#### ShardedMap 测试（3h）

**文件**: `internal/storage/sharded_map_test.go`

**测试清单**:
- [ ] `TestNewShardedMap` - 测试构造函数
  ```go
  func TestNewShardedMap(t *testing.T) {
      sm := NewShardedMap(1024)
      assert.NotNil(t, sm)
      assert.Equal(t, 0, sm.Len())
  }
  ```
- [ ] `TestShardedMap_SetGet` - 测试设置和获取
  ```go
  func TestShardedMap_SetGet(t *testing.T) {
      sm := NewShardedMap(1024)

      err := sm.Set("key1", "value1", 0)
      assert.NoError(t, err)

      value, found := sm.Get("key1")
      assert.True(t, found)
      assert.Equal(t, "value1", value)
  }
  ```
- [ ] `TestShardedMap_Delete` - 测试删除
- [ ] `TestShardedMap_Exists` - 测试存在性检查
- [ ] `TestShardedMap_Len` - 测试长度统计
- [ ] `TestShardedMap_SetOverwrite` - 测试覆盖已存在的键
- [ ] `TestShardedMap_GetNonExistent` - 测试获取不存在的键
- [ ] `TestShardedMap_DeleteNonExistent` - 测试删除不存在的键
- [ ] `TestShardedMap_EmptyKey` - 测试空键名
- [ ] `TestShardedMap_LargeValue` - 测试大值（1MB+）
- [ ] `TestShardedMap_ManyKeys` - 测试大量键（100K+）

**并发测试**:
- [ ] `TestShardedMap_ConcurrentSet` - 并发写入
  ```go
  func TestShardedMap_ConcurrentSet(t *testing.T) {
      sm := NewShardedMap(1024)
      var wg sync.WaitGroup

      for i := 0; i < 100; i++ {
          wg.Add(1)
          go func(n int) {
              defer wg.Done()
              key := fmt.Sprintf("key%d", n)
              sm.Set(key, n, 0)
          }(i)
      }

      wg.Wait()
      assert.Equal(t, 100, sm.Len())
  }
  ```
- [ ] `TestShardedMap_ConcurrentGet` - 并发读取
- [ ] `TestShardedMap_ConcurrentMixed` - 混合读写
- [ ] `TestShardedMap_RaceCondition` - 数据竞争测试（`-race`）

**性能基准测试**:
- [ ] `BenchmarkShardedMap_Set` - Set 性能
- [ ] `BenchmarkShardedMap_Get` - Get 性能
- [ ] `BenchmarkShardedMap_Delete` - Delete 性能
- [ ] `BenchmarkShardedMap_Parallel` - 并发性能

**验收标准**:
- 所有测试通过
- 覆盖率 > 90%
- 无数据竞争
- Get 性能 > 1M ops/s（单分片）

---

#### TTL 管理测试（2h）

**文件**: `internal/storage/ttl_test.go`

**测试清单**:
- [ ] `TestTTL_BasicExpiry` - 基础过期测试
  ```go
  func TestTTL_BasicExpiry(t *testing.T) {
      sm := NewShardedMap(1024)

      // 设置 1 秒过期
      sm.Set("key", "value", 1)

      // 立即获取应该成功
      value, found := sm.Get("key")
      assert.True(t, found)
      assert.Equal(t, "value", value)

      // 等待过期
      time.Sleep(1100 * time.Millisecond)

      // 应该已过期
      _, found = sm.Get("key")
      assert.False(t, found)
  }
  ```
- [ ] `TestTTL_LazyDeletion` - 惰性删除测试
- [ ] `TestTTL_PeriodicCleanup` - 定期清理测试
- [ ] `TestTTL_ZeroTTL` - TTL=0（永不过期）
- [ ] `TestTTL_NegativeTTL` - 负数 TTL（立即过期）
- [ ] `TestTTL_UpdateTTL` - 更新 TTL（EXPIRE 命令）
- [ ] `TestTTL_GetRemainingTTL` - 获取剩余 TTL
- [ ] `TestTTL_MassExpiry` - 大量键同时过期

**性能测试**:
- [ ] `TestTTL_CleanupPerformance` - 清理性能（CPU 占用 < 5%）
- [ ] `BenchmarkTTL_SetWithTTL` - 带 TTL 的 Set 性能
- [ ] `BenchmarkTTL_GetExpired` - 过期键 Get 性能

**验收标准**:
- 过期机制准确（误差 < 100ms）
- 清理不影响性能
- 覆盖率 > 85%

---

#### LRU 缓存测试（1h）

**文件**: `internal/storage/lru_test.go`

**测试清单**:
- [ ] `TestLRU_BasicEviction` - 基础淘汰测试
  ```go
  func TestLRU_BasicEviction(t *testing.T) {
      lru := NewLRUCache(3)

      lru.Set("a", 1)
      lru.Set("b", 2)
      lru.Set("c", 3)

      // 超过容量，应淘汰最久未使用的 "a"
      lru.Set("d", 4)

      _, found := lru.Get("a")
      assert.False(t, found)
  }
  ```
- [ ] `TestLRU_AccessOrder` - 访问顺序测试
- [ ] `TestLRU_Update` - 更新现有键
- [ ] `TestLRU_HitRate` - 缓存命中率测试（> 90%）
- [ ] `BenchmarkLRU_Set`
- [ ] `BenchmarkLRU_Get`

**验收标准**:
- LRU 淘汰策略正确
- 缓存命中率 > 90%（模拟负载）

---

### 1.2 传输层测试（6h）

**Issue**: `[Test] 传输层单元测试`
**优先级**: P0
**预估**: 6h
**负责**: 测试工程师

#### RESP 协议测试（3h）

**文件**: `internal/transport/resp/parser_test.go`

**测试清单**:
- [ ] `TestRESP_ParseSimpleString` - 解析简单字符串
  ```go
  func TestRESP_ParseSimpleString(t *testing.T) {
      reader := bufio.NewReader(strings.NewReader("+OK\r\n"))
      value, err := ParseRESP(reader)

      assert.NoError(t, err)
      assert.Equal(t, SimpleString, value.Type)
      assert.Equal(t, "OK", value.Str)
  }
  ```
- [ ] `TestRESP_ParseError` - 解析错误
- [ ] `TestRESP_ParseInteger` - 解析整数
- [ ] `TestRESP_ParseBulkString` - 解析 Bulk String
- [ ] `TestRESP_ParseNullBulkString` - 解析 Null Bulk String
- [ ] `TestRESP_ParseArray` - 解析数组
- [ ] `TestRESP_ParseNestedArray` - 解析嵌套数组
- [ ] `TestRESP_ParseEmptyArray` - 解析空数组
- [ ] `TestRESP_ParseLargeBulkString` - 解析大字符串（1MB+）
- [ ] `TestRESP_ParseMalformed` - 解析格式错误的数据
- [ ] `TestRESP_WriteSimpleString` - 序列化简单字符串
- [ ] `TestRESP_WriteError` - 序列化错误
- [ ] `TestRESP_WriteBulkString` - 序列化 Bulk String
- [ ] `TestRESP_WriteArray` - 序列化数组

**性能测试**:
- [ ] `BenchmarkRESP_Parse` - 解析性能 (> 100K ops/s)
- [ ] `BenchmarkRESP_Write` - 序列化性能

**验收标准**:
- 兼容 Redis RESP 协议
- 覆盖率 > 95%
- 解析速度 > 100K ops/s

---

#### 命令处理器测试（3h）

**文件**: `internal/transport/tcp/handler_test.go`

**测试清单**:
- [ ] `TestCommand_GET` - GET 命令
  ```go
  func TestCommand_GET(t *testing.T) {
      handler := NewCommandHandler(storage)
      storage.Set("key1", "value1", 0)

      args := []RESPValue{
          {Type: BulkString, Bulk: []byte("GET")},
          {Type: BulkString, Bulk: []byte("key1")},
      }

      result := handler.Handle(args)
      assert.Equal(t, BulkString, result.Type)
      assert.Equal(t, "value1", string(result.Bulk))
  }
  ```
- [ ] `TestCommand_SET` - SET 命令（无 TTL）
- [ ] `TestCommand_SET_EX` - SET 命令（带 EX 选项）
- [ ] `TestCommand_SET_InvalidArgs` - SET 参数错误
- [ ] `TestCommand_DEL` - DEL 命令（单键）
- [ ] `TestCommand_DEL_Multiple` - DEL 命令（多键）
- [ ] `TestCommand_EXISTS` - EXISTS 命令
- [ ] `TestCommand_TTL` - TTL 命令
- [ ] `TestCommand_EXPIRE` - EXPIRE 命令
- [ ] `TestCommand_PING` - PING 命令
- [ ] `TestCommand_ECHO` - ECHO 命令
- [ ] `TestCommand_InvalidCommand` - 无效命令
- [ ] `TestCommand_CaseSensitivity` - 命令大小写（GET/get）

**验收标准**:
- 所有命令符合 Redis 语义
- 错误处理完整
- 覆盖率 > 90%

---

### 1.3 协议层测试（4h）

**Issue**: `[Test] OAuth 2.0 协议单元测试`
**优先级**: P0
**预估**: 4h
**负责**: 测试工程师

#### Token 存储测试（2h）

**文件**: `internal/protocol/oauth/token_test.go`

**测试清单**:
- [ ] `TestOAuth_StoreAccessToken` - 存储访问令牌
  ```go
  func TestOAuth_StoreAccessToken(t *testing.T) {
      store := NewTokenStore(storage)

      token := &OAuthToken{
          AccessToken: "access_token_123",
          TokenType:   "Bearer",
          ExpiresIn:   3600,
          Scope:       "read write",
          UserID:      "user001",
          ClientID:    "client001",
      }

      err := store.StoreAccessToken(token, 3600)
      assert.NoError(t, err)

      retrieved, err := store.GetAccessToken("access_token_123")
      assert.NoError(t, err)
      assert.Equal(t, token.UserID, retrieved.UserID)
  }
  ```
- [ ] `TestOAuth_GetAccessToken` - 获取访问令牌
- [ ] `TestOAuth_DeleteAccessToken` - 删除访问令牌
- [ ] `TestOAuth_StoreRefreshToken` - 存储刷新令牌
- [ ] `TestOAuth_GetRefreshToken` - 获取刷新令牌
- [ ] `TestOAuth_TokenExpiry` - Token 过期测试
- [ ] `TestOAuth_TokenSerialization` - Token 序列化/反序列化
- [ ] `TestOAuth_InvalidJSON` - 无效 JSON 处理

**验收标准**:
- Token 存储和检索正确
- JSON 序列化正确
- 覆盖率 > 85%

---

#### Authorization Code 测试（1h）

**文件**: `internal/protocol/oauth/authcode_test.go`

**测试清单**:
- [ ] `TestAuthCode_Store` - 存储授权码
- [ ] `TestAuthCode_Get` - 获取授权码
- [ ] `TestAuthCode_Delete` - 删除授权码
- [ ] `TestAuthCode_OneTimeUse` - 一次性使用测试
- [ ] `TestAuthCode_Expiry` - 授权码过期（10 分钟）
- [ ] `TestAuthCode_ReplayAttack` - 防重放测试

**验收标准**:
- 授权码只能使用一次
- 过期机制正确

---

#### Token Introspection 测试（1h）

**文件**: `internal/protocol/oauth/introspection_test.go`

**测试清单**:
- [ ] `TestIntrospection_ActiveToken` - 有效 Token
  ```go
  func TestIntrospection_ActiveToken(t *testing.T) {
      store := NewTokenStore(storage)

      token := &OAuthToken{
          AccessToken: "token_123",
          UserID:      "user001",
          ClientID:    "client001",
          Scope:       "read",
      }
      store.StoreAccessToken(token, 3600)

      resp := store.IntrospectToken("token_123")
      assert.True(t, resp.Active)
      assert.Equal(t, "user001", resp.Username)
  }
  ```
- [ ] `TestIntrospection_ExpiredToken` - 过期 Token
- [ ] `TestIntrospection_InvalidToken` - 无效 Token
- [ ] `TestIntrospection_Response` - 响应格式（RFC 7662）

**验收标准**:
- 符合 RFC 7662 规范
- 覆盖率 > 90%

---

## 2. 集成测试（12 小时）

### 2.1 TCP 服务器集成测试（6h）

**Issue**: `[Test] TCP 服务器集成测试`
**优先级**: P0
**预估**: 6h
**负责**: 测试工程师

**文件**: `tests/integration/tcp_test.go`

**测试清单**:
- [ ] `TestTCP_ServerStartStop` - 服务器启停
  ```go
  func TestTCP_ServerStartStop(t *testing.T) {
      server := NewTCPServer(":16380", storage)

      // 启动服务器
      go server.Start()
      time.Sleep(100 * time.Millisecond)

      // 停止服务器
      err := server.Stop()
      assert.NoError(t, err)
  }
  ```
- [ ] `TestTCP_ClientConnection` - 客户端连接
  ```go
  func TestTCP_ClientConnection(t *testing.T) {
      server := startTestServer(t)
      defer server.Stop()

      // 使用 redis-cli 连接
      client := redis.NewClient(&redis.Options{
          Addr: "localhost:16380",
      })
      defer client.Close()

      // 测试 PING
      pong, err := client.Ping(ctx).Result()
      assert.NoError(t, err)
      assert.Equal(t, "PONG", pong)
  }
  ```
- [ ] `TestTCP_SET_GET_DEL` - SET/GET/DEL 命令流程
- [ ] `TestTCP_TTLExpiry` - TTL 过期集成测试
- [ ] `TestTCP_MultipleClients` - 多客户端连接
- [ ] `TestTCP_ConnectionTimeout` - 连接超时
- [ ] `TestTCP_IdleTimeout` - 空闲超时
- [ ] `TestTCP_MaxConnections` - 最大连接数限制
- [ ] `TestTCP_GracefulShutdown` - 优雅关闭（不丢失数据）
- [ ] `TestTCP_PipelineCommands` - 管道命令
- [ ] `TestTCP_LargePayload` - 大数据传输（10MB+）

**验收标准**:
- 所有集成测试通过
- 优雅关闭无数据丢失
- 支持 10,000+ 并发连接

---

### 2.2 OAuth 2.0 集成测试（4h）

**Issue**: `[Test] OAuth 2.0 端到端测试`
**优先级**: P0
**预估**: 4h
**负责**: 测试工程师

**文件**: `tests/integration/oauth_test.go`

**测试清单**:
- [ ] `TestOAuth_AuthorizationCodeFlow` - 授权码流程
  ```go
  func TestOAuth_AuthorizationCodeFlow(t *testing.T) {
      store := NewTokenStore(storage)

      // 1. 存储授权码
      authCode := &AuthorizationCode{
          Code:        "code_123",
          ClientID:    "client001",
          RedirectURI: "https://example.com/callback",
          UserID:      "user001",
      }
      store.StoreAuthCode(authCode, 600)

      // 2. 交换 Token
      retrieved, found := store.GetAuthCode("code_123")
      assert.True(t, found)

      // 3. 删除授权码（一次性使用）
      store.DeleteAuthCode("code_123")

      // 4. 存储 Access Token
      token := &OAuthToken{
          AccessToken:  "access_token_123",
          RefreshToken: "refresh_token_123",
          ExpiresIn:    3600,
          UserID:       retrieved.UserID,
      }
      store.StoreAccessToken(token, 3600)

      // 5. 验证 Token
      resp := store.IntrospectToken("access_token_123")
      assert.True(t, resp.Active)
  }
  ```
- [ ] `TestOAuth_ImplicitFlow` - 隐式流程（仅 Access Token）
- [ ] `TestOAuth_ClientCredentials` - 客户端凭证流程
- [ ] `TestOAuth_RefreshToken` - 刷新令牌流程
- [ ] `TestOAuth_TokenRevocation` - Token 撤销

**验收标准**:
- 覆盖主要 OAuth 2.0 流程
- 流程符合 RFC 6749 规范

---

### 2.3 CLI 工具集成测试（2h）

**Issue**: `[Test] CLI 工具集成测试`
**优先级**: P1
**预估**: 2h
**负责**: 测试工程师

**测试清单**:
- [ ] `TestCLI_ServerStart` - 服务器启动
  ```bash
  ./tokenginx-server -config config.yaml &
  sleep 1
  redis-cli -p 6380 PING
  # 预期：PONG
  ```
- [ ] `TestCLI_ClientConnect` - 客户端连接
  ```bash
  ./tokenginx-client -server localhost:6380 -c "SET key value"
  # 预期：OK
  ./tokenginx-client -server localhost:6380 -c "GET key"
  # 预期："value"
  ```
- [ ] `TestCLI_ConfigFile` - 配置文件加载
- [ ] `TestCLI_EnvVars` - 环境变量配置
- [ ] `TestCLI_Version` - 版本信息
- [ ] `TestCLI_Help` - 帮助信息

**验收标准**:
- 命令行工具正常工作
- 配置加载正确

---

## 3. 性能测试（6 小时）

### 3.1 基准测试（4h）

**Issue**: `[Test] 性能基准测试`
**优先级**: P0
**预估**: 4h
**负责**: 测试工程师

**文件**: `tests/benchmark/benchmark_test.go`

**测试清单**:
- [ ] `BenchmarkServer_SET` - SET 命令性能
  ```go
  func BenchmarkServer_SET(b *testing.B) {
      server := startTestServer(b)
      defer server.Stop()

      client := redis.NewClient(&redis.Options{
          Addr: "localhost:16380",
      })
      defer client.Close()

      b.ResetTimer()
      for i := 0; i < b.N; i++ {
          key := fmt.Sprintf("key%d", i)
          client.Set(ctx, key, "value", 0)
      }
  }
  ```
- [ ] `BenchmarkServer_GET` - GET 命令性能
- [ ] `BenchmarkServer_DEL` - DEL 命令性能
- [ ] `BenchmarkServer_Mixed` - 混合负载（70% GET, 30% SET）
- [ ] `BenchmarkServer_ParallelGET` - 并发 GET
- [ ] `BenchmarkServer_Pipeline` - 管道性能
- [ ] `BenchmarkLatency_P50` - P50 延迟
- [ ] `BenchmarkLatency_P99` - P99 延迟
- [ ] `BenchmarkLatency_P999` - P999 延迟

**性能目标**:
- QPS > 100,000（单节点）
- P50 < 0.5ms
- P99 < 1ms
- P999 < 5ms

**验收标准**:
- 所有性能指标达标
- 延迟分布合理

---

### 3.2 压力测试（2h）

**Issue**: `[Test] 压力和稳定性测试`
**优先级**: P1
**预估**: 2h
**负责**: 测试工程师

**测试清单**:
- [ ] `TestStress_10KConnections` - 10,000 并发连接
  ```bash
  # 使用 redis-benchmark
  redis-benchmark -h localhost -p 6380 \
    -c 10000 -n 1000000 -t set,get \
    -d 1024 --csv
  ```
- [ ] `TestStress_LongRunning` - 长时间运行（24 小时）
- [ ] `TestStress_MemoryLeak` - 内存泄漏测试
- [ ] `TestStress_GoroutineLeak` - Goroutine 泄漏测试
- [ ] `TestStress_CPUUsage` - CPU 使用率（< 80%）
- [ ] `TestStress_RecoveryAfterCrash` - 崩溃恢复测试

**验收标准**:
- 无内存泄漏
- 无 Goroutine 泄漏
- CPU 使用率稳定
- 长时间运行稳定

---

## 4. 安全测试（4 小时）

### 4.1 边界测试（2h）

**Issue**: `[Test] 边界和异常测试`
**优先级**: P1
**预估**: 2h
**负责**: 测试工程师

**测试清单**:
- [ ] `TestSecurity_EmptyKey` - 空键名
- [ ] `TestSecurity_LongKey` - 超长键名（1MB+）
- [ ] `TestSecurity_LargeValue` - 超大值（100MB+）
- [ ] `TestSecurity_NullBytes` - Null 字节注入
- [ ] `TestSecurity_SpecialChars` - 特殊字符（\r\n, \x00）
- [ ] `TestSecurity_MalformedRESP` - 格式错误的 RESP
- [ ] `TestSecurity_BufferOverflow` - 缓冲区溢出尝试
- [ ] `TestSecurity_CommandInjection` - 命令注入尝试

**验收标准**:
- 所有边界情况处理正确
- 无崩溃或内存错误

---

### 4.2 并发安全测试（2h）

**Issue**: `[Test] 并发安全和数据竞争测试`
**优先级**: P0
**预估**: 2h
**负责**: 测试工程师

**测试清单**:
- [ ] `TestRace_AllModules` - 全模块数据竞争检测
  ```bash
  go test -race ./...
  ```
- [ ] `TestConcurrency_1000Writers` - 1000 并发写
- [ ] `TestConcurrency_1000Readers` - 1000 并发读
- [ ] `TestConcurrency_MixedReadWrite` - 混合读写
- [ ] `TestDeadlock_Detection` - 死锁检测

**验收标准**:
- `go test -race` 全部通过
- 无死锁情况

---

## 测试工具和脚本

### 测试脚本

创建 `scripts/run-tests.sh`：

```bash
#!/bin/bash
set -e

echo "===== Running Unit Tests ====="
go test -v -cover ./internal/...

echo "===== Running Integration Tests ====="
go test -v ./tests/integration/...

echo "===== Running Race Detection ====="
go test -race ./...

echo "===== Running Benchmarks ====="
go test -bench=. -benchmem ./internal/storage/

echo "===== Generating Coverage Report ====="
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html

echo "===== All Tests Passed! ====="
```

### CI 集成

`.github/workflows/ci.yml` 已包含：

```yaml
- name: Run tests
  run: |
    go test -v -race -coverprofile=coverage.out ./...
    go tool cover -func=coverage.out

- name: Upload coverage
  uses: codecov/codecov-action@v3
  with:
    files: ./coverage.out
```

## 测试时间表

### 周测试计划

| 周次 | 测试内容 | 工时 |
|-----|---------|------|
| Week 1-2 | 开发阶段（边开发边单元测试） | 16h |
| Week 3 | 单元测试补充 | 8h |
| Week 4 | 集成测试 | 12h |
| Week 5 | 性能测试 | 6h |
| Week 6 | 安全测试 + Bug 修复 | 4h + 缓冲 |

**总计**：38h 测试 + 缓冲时间

## 测试总结

### 测试覆盖率目标

| 模块 | 单元测试覆盖率 | 集成测试 |
|-----|--------------|---------|
| 存储引擎 | > 90% | ✅ |
| 传输层 | > 90% | ✅ |
| 协议层 | > 85% | ✅ |
| 配置系统 | > 80% | ✅ |
| CLI 工具 | > 70% | ✅ |
| **总体** | **> 80%** | **✅** |

### Bug 跟踪

所有测试中发现的 Bug 应创建 Issue，并标记为：
- `bug` 标签
- 关联的测试用例
- 复现步骤
- 优先级（P0-P3）

### 验收标准

v0.1.0 发布前必须满足：

- [ ] 所有单元测试通过
- [ ] 所有集成测试通过
- [ ] `go test -race` 通过（无数据竞争）
- [ ] 单元测试覆盖率 > 80%
- [ ] 性能达标（QPS > 100K, P99 < 1ms）
- [ ] 无已知 P0/P1 Bug
- [ ] 文档完整（所有功能有文档）

## 相关资源

- [开发任务清单](./v0.1.0-dev-tasks.md)
- [项目路线图](./roadmap.md)
- [贡献指南](../../contributing.md)
- [Go 测试最佳实践](https://golang.org/doc/effective_go#testing)
